#!/usr/bin/env python3
"""
Create an enhanced Colab notebook with proper #@title and #@param annotations
and fix CalledProcessError issues.
"""

import json
from pathlib import Path

def create_enhanced_notebook():
    # Create enhanced notebook structure
    notebook = {
        "cells": [
            # Cell 1: Header
            {
                "cell_type": "markdown",
                "metadata": {"id": "header"},
                "source": [
                    "# üöÄ Advanced RVC Inference Pro\n",
                    "\n",
                    "**State-of-the-art Voice Conversion with KADVC Optimization**\n",
                    "\n",
                    "> **Single Source of Truth (SSOT) Colab Notebook**\n",
                    "\n",
                    "This notebook provides:\n",
                    "- ‚ö° **Dependency Caching** - Skip installation on restarts\n",
                    "- üóÑÔ∏è **Drive Mounting** - Auto symlink weights folder\n",
                    "- üåê **Tunneling** - Robust Gradio/ngrok integration  \n",
                    "- üéØ **GPU Auto-detection** - Tesla T4/P100/A100 optimization\n",
                    "- üß† **Memory Management** - Automatic OOM prevention\n",
                    "- üéµ **Voice Processing** - High-quality RVC voice conversion\n",
                    "- üîß **Model Loading** - Automatic model detection and loading\n",
                    "\n",
                    "**Repository:** [ArkanDash/Advanced-RVC-Inference](https://github.com/ArkanDash/Advanced-RVC-Inference)\n",
                    "\n",
                    "**Author:** BF667"
                ]
            },
            
            # Cell 2: Colab Parameters
            {
                "cell_type": "markdown",
                "metadata": {"id": "colab-parameters"},
                "source": [
                    "# Colab Parameters\n",
                    "\n",
                    "<!-- This cell contains parameters for the notebook. These parameters should not be modified. -->\n",
                    "<!-- Parameters specific to Advanced RVC Inference -->\n"
                ]
            },
            
            # Cell 3: Install Dependencies
            {
                "cell_type": "markdown",
                "metadata": {"id": "install_dependencies"},
                "source": [
                    "#@title ## üì¶ Install & Setup Dependencies\n",
                    "\n",
                    "This cell includes intelligent caching to save 3-5 minutes on restarts!"
                ]
            },
            
            # Cell 4: Dependency Install Code
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {
                    "id": "dependency_install",
                    "colab": {"base_uri": "https://localhost:8080/"}
                },
                "outputs": [],
                "source": [
                    "#@title Install Dependencies with Caching\n",
                    "#@param {\"type\": \"string\", \"description\": \"Optional: Custom CUDA version (leave empty for auto-detect)\"} \n",
                    "cuda_version = \"\"  # e.g., \"11.8\" or \"12.1\", leave empty for auto\n",
                    "\n",
                    "# ============================================\n",
                    "# ADVANCED RVC DEPENDENCY INSTALLATION\n",
                    "# WITH INTELLIGENT CACHING & OPTIMIZATION\n",
                    "# ============================================\n",
                    "\n",
                    "import os\n",
                    "import sys\n",
                    "import time\n",
                    "import subprocess\n",
                    "import json\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# Check if running in Colab\n",
                    "try:\n",
                    "    import google.colab\n",
                    "    IN_COLAB = True\n",
                    "    print(\"üöÄ Running in Google Colab environment\")\n",
                    "except ImportError:\n",
                    "    IN_COLAB = False\n",
                    "    print(\"‚ö†Ô∏è Not running in Colab - some features may not work\")\n",
                    "\n",
                    "# Setup paths\n",
                    "BASE_DIR = Path.cwd()\n",
                    "CACHE_FILE = BASE_DIR / \".colab_deps_cache.json\"\n",
                    "\n",
                    "# Install CUDA toolkit if specified\n",
                    "if cuda_version and IN_COLAB:\n",
                    "    print(f\"üñ•Ô∏è Installing CUDA {cuda_version} toolkit...\")\n",
                    "    subprocess.run([\"apt\", \"update\"], check=True)\n",
                    "    subprocess.run([\"apt\", \"install\", \"-y\", f\"cuda-toolkit-{cuda_version}\"], check=True)\n",
                    "\n",
                    "# Define package requirements\n",
                    "REQUIREMENTS = [\n",
                    "    \"torch>=2.0.0\",\n",
                    "    \"torchvision\",\n",
                    "    \"torchaudio\",\n",
                    "    \"librosa\",\n",
                    "    \"soundfile\",\n",
                    "    \"numpy\",\n",
                    "    \"scipy\",\n",
                    "    \"gradio>=3.50.0\",\n",
                    "    \"transformers\",\n",
                    "    \"huggingface-hub\",\n",
                    "    \"omegaconf\",\n",
                    "    \"numba\",\n",
                    "    \"ffmpeg-python\",\n",
                    "    \"audioread\",\n",
                    "    \"soundfile\",\n",
                    "    \"resampy\",\n",
                    "    \"parselmouth\",\n",
                    "]\n",
                    "\n",
                    "# Cache management\n",
                    "def load_cache():\n",
                    "    if CACHE_FILE.exists():\n",
                    "        with open(CACHE_FILE, \"r\") as f:\n",
                    "            return json.load(f)\n",
                    "    return {}\n",
                    "\n",
                    "def save_cache(cache):\n",
                    "    with open(CACHE_FILE, \"w\") as f:\n",
                    "        json.dump(cache, f, indent=2)\n",
                    "\n",
                    "# Check if packages are already installed\n",
                    "def check_package_installed(package_name):\n",
                    "    try:\n",
                    "        result = subprocess.run(\n",
                    "            [\"pip\", \"show\", package_name.split(\">=\")[0].split(\"<\")[0].split(\"==\")[0]],\n",
                    "            capture_output=True,\n",
                    "            text=True,\n",
                    "            timeout=10\n",
                    "        )\n",
                    "        return result.returncode == 0\n",
                    "    except (subprocess.TimeoutExpired, subprocess.SubprocessError):\n",
                    "        return False\n",
                    "\n",
                    "# Main installation logic\n",
                    "print(\"üîç Checking existing package installation...\")\n",
                    "cache = load_cache()\n",
                    "start_time = time.time()\n",
                    "\n",
                    "# Install packages that are not already installed\n",
                    "packages_to_install = []\n",
                    "for req in REQUIREMENTS:\n",
                    "    package_name = req.split(\">=\")[0].split(\"<\")[0].split(\"==\")[0]\n",
                    "    if not check_package_installed(package_name):\n",
                    "        packages_to_install.append(req)\n",
                    "        print(f\"  ‚ûï Will install: {req}\")\n",
                    "    else:\n",
                    "        print(f\"  ‚úÖ Already installed: {package_name}\")\n",
                    "\n",
                    "if packages_to_install:\n",
                    "    print(f\"\\nüì¶ Installing {len(packages_to_install)} packages...\")\n",
                    "    \n",
                    "    # Install PyTorch first (important for CUDA)\n",
                    "    torch_reqs = [req for req in packages_to_install if \"torch\" in req.lower()]\n",
                    "    other_reqs = [req for req in packages_to_install if \"torch\" not in req.lower()]\n",
                    "    \n",
                    "    if torch_reqs:\n",
                    "        print(\"üî• Installing PyTorch components...\")\n",
                    "        subprocess.run([\"pip\", \"install\"] + torch_reqs + [\"--index-url\", \"https://download.pytorch.org/whl/cu118\"], check=True)\n",
                    "    \n",
                    "    if other_reqs:\n",
                    "        print(\"üìö Installing other dependencies...\")\n",
                    "        subprocess.run([\"pip\", \"install\"] + other_reqs, check=True)\n",
                    "        \n",
                    "    print(\"‚úÖ All packages installed successfully!\")\n",
                    "else:\n",
                    "    print(\"\\nüéâ All required packages are already installed!\")\n",
                    "\n",
                    "# Verify critical packages\n",
                    "critical_packages = [\"torch\", \"gradio\", \"librosa\"]\n",
                    "print(\"\\nüîç Verifying critical packages...\")\n",
                    "for pkg in critical_packages:\n",
                    "    if check_package_installed(pkg):\n",
                    "        print(f\"  ‚úÖ {pkg}\")\n",
                    "    else:\n",
                    "        print(f\"  ‚ùå {pkg} - Installation failed!\")\n",
                    "\n",
                    "installation_time = time.time() - start_time\n",
                    "print(f\"\\n‚è±Ô∏è Total installation time: {installation_time:.2f} seconds\")\n",
                    "print(\"\\nüéâ Dependency installation completed!\")"
                ]
            },
            
            # Cell 5: Drive Mount
            {
                "cell_type": "markdown",
                "metadata": {"id": "drive_mount"},
                "source": [
                    "#@title ## üóÑÔ∏è Mount Google Drive & Setup Symlinks\n",
                    "\n",
                    "Configure persistent storage for your RVC models."
                ]
            },
            
            # Cell 6: Drive Setup Code
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {
                    "id": "drive_setup",
                    "colab": {"base_uri": "https://localhost:8080/"}
                },
                "outputs": [],
                "source": [
                    "#@title Setup Google Drive Storage\n",
                    "#@param {\"type\": \"string\", \"description\": \"Base directory name for RVC models on Drive\"} \n",
                    "rvc_directory_name = \"RVC_Models\"\n",
                    "#@param {\"type\": \"string\", \"description\": \"Create backup of existing models folder\"} \n",
                    "backup_existing = \"yes\"  # \"yes\" or \"no\"\n",
                    "\n",
                    "# ============================================\n",
                    "# GOOGLE DRIVE MOUNTING & SYMLINK SETUP\n",
                    "# ============================================\n",
                    "\n",
                    "import os\n",
                    "import subprocess\n",
                    "from pathlib import Path\n",
                    "\n",
                    "try:\n",
                    "    from google.colab import drive\n",
                    "    print(\"üîó Mounting Google Drive...\")\n",
                    "    drive.mount(\"/content/drive\")\n",
                    "    print(\"‚úÖ Google Drive mounted successfully\")\n",
                    "except ImportError:\n",
                    "    print(\"‚ö†Ô∏è Google Colab modules not available - skipping drive mounting\")\n",
                    "    exit(1)\n",
                    "\n",
                    "# Define paths\n",
                    "DRIVE_BASE = Path(\"/content/drive/MyDrive\")\n",
                    "WORKSPACE = Path.cwd()\n",
                    "\n",
                    "# Create RVC directory on Drive\n",
                    "RVC_DIR = DRIVE_BASE / rvc_directory_name\n",
                    "RVC_DIR.mkdir(parents=True, exist_ok=True)\n",
                    "\n",
                    "# Setup symlinks for persistent storage\n",
                    "symlinks = [\n",
                    "    (\"weights\", RVC_DIR / \"weights\"),\n",
                    "    (\"indexes\", RVC_DIR / \"indexes\"),\n",
                    "    (\"logs\", RVC_DIR / \"logs\"),\n",
                    "    (\"cache\", RVC_DIR / \"cache\")\n",
                    "]\n",
                    "\n",
                    "print(\"üîó Setting up symlinks for persistent storage...\")\n",
                    "for local_name, drive_path in symlinks:\n",
                    "    local_path = WORKSPACE / local_name\n",
                    "    \n",
                    "    if local_path.exists() and not local_path.is_symlink():\n",
                    "        if backup_existing.lower() == \"yes\":\n",
                    "            # Backup existing directory\n",
                    "            backup_path = local_path.parent / f\"{local_name}_backup\"\n",
                    "            local_path.rename(backup_path)\n",
                    "            print(f\"üì¶ Backed up {local_name} to {backup_path}\")\n",
                    "        else:\n",
                    "            # Remove existing directory\n",
                    "            subprocess.run([\"rm\", \"-rf\", str(local_path)], check=True)\n",
                    "            print(f\"üóëÔ∏è Removed existing {local_name} directory\")\n",
                    "    \n",
                    "    # Create symlink\n",
                    "    try:\n",
                    "        if local_path.is_symlink():\n",
                    "            local_path.unlink()\n",
                    "        elif local_path.exists():\n",
                    "            subprocess.run([\"rm\", \"-rf\", str(local_path)], check=True)\n",
                    "        \n",
                    "        # Ensure drive directory exists\n",
                    "        drive_path.mkdir(parents=True, exist_ok=True)\n",
                    "        \n",
                    "        # Create symlink\n",
                    "        os.symlink(drive_path, local_path)\n",
                    "        print(f\"‚úÖ Linked {local_name} -> {drive_path}\")\n",
                    "        \n",
                    "    except Exception as e:\n",
                    "        print(f\"‚ö†Ô∏è Could not symlink {local_name}: {e}\")\n",
                    "\n",
                    "print(f\"\\nüíæ Your RVC models will be saved to: {RVC_DIR}\")\n",
                    "print(\"üîÑ They will persist across Colab sessions!\")"
                ]
            },
            
            # Cell 7: Project Setup
            {
                "cell_type": "markdown",
                "metadata": {"id": "project_setup"},
                "source": [
                    "#@title ## üìÅ Project Setup\n",
                    "\n",
                    "Clone the repository and configure the project structure."
                ]
            },
            
            # Cell 8: Clone Repo Code
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {
                    "id": "clone_repo",
                    "colab": {"base_uri": "https://localhost:8080/"}
                },
                "outputs": [],
                "source": [
                    "#@title Clone and Setup Repository\n",
                    "#@param {\"type\": \"string\", \"description\": \"GitHub repository URL (leave empty for default)\"} \n",
                    "repo_url = \"\"\n",
                    "#@param {\"type\": \"string\", \"description\": \"Branch to use (leave empty for master)\"} \n",
                    "branch = \"\"\n",
                    "\n",
                    "# ============================================\n",
                    "# PROJECT CLONING & SETUP\n",
                    "# ============================================\n",
                    "\n",
                    "import os\n",
                    "import subprocess\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# Set defaults\n",
                    "if not repo_url:\n",
                    "    REPO_URL = \"https://github.com/ArkanDash/Advanced-RVC-Inference.git\"\n",
                    "else:\n",
                    "    REPO_URL = repo_url\n",
                    "    \n",
                    "if not branch:\n",
                    "    REPO_BRANCH = \"master\"\n",
                    "else:\n",
                    "    REPO_BRANCH = branch\n",
                    "\n",
                    "PROJECT_DIR = Path.cwd() / \"Advanced-RVC-Inference\"\n",
                    "\n",
                    "if not PROJECT_DIR.exists():\n",
                    "    print(\"üì• Cloning Advanced RVC Inference repository...\")\n",
                    "    print(f\"üåê URL: {REPO_URL}\")\n",
                    "    print(f\"üåø Branch: {REPO_BRANCH}\")\n",
                    "    subprocess.run([\"git\", \"clone\", \"-b\", REPO_BRANCH, REPO_URL, str(PROJECT_DIR)], check=True)\n",
                    "    print(\"‚úÖ Repository cloned successfully\")\n",
                    "else:\n",
                    "    print(\"üìÅ Repository already exists, updating...\")\n",
                    "    os.chdir(PROJECT_DIR)\n",
                    "    # Use the correct branch (master)\n",
                    "    subprocess.run([\"git\", \"pull\", \"origin\", \"master\"], check=True)\n",
                    "    print(\"‚úÖ Repository updated\")\n",
                    "\n",
                    "# Change to project directory\n",
                    "os.chdir(PROJECT_DIR)\n",
                    "print(f\"üìÇ Working directory: {PROJECT_DIR}\")\n",
                    "\n",
                    "# Install project requirements (FIXED - no -e flag to avoid CalledProcessError)\n",
                    "print(\"üì¶ Installing project requirements...\")\n",
                    "if (PROJECT_DIR / \"requirements.txt\").exists():\n",
                    "    subprocess.run([\"pip\", \"install\", \"-r\", \"requirements.txt\"], check=True)\n",
                    "    print(\"‚úÖ Requirements installed successfully\")\n",
                    "else:\n",
                    "    print(\"‚ö†Ô∏è No requirements.txt found, skipping requirements installation\")\n",
                    "\n",
                    "# Set up environment variables\n",
                    "os.environ[\"PYTHONPATH\"] = str(PROJECT_DIR)\n",
                    "print(\"üåç Python path configured\")"
                ]
            },
            
            # Cell 9: Tunneling
            {
                "cell_type": "markdown",
                "metadata": {"id": "tunneling"},
                "source": [
                    "#@title ## üåê Setup Tunneling (Choose One)\n",
                    "\n",
                    "Configure tunneling options to access the Gradio interface."
                ]
            },
            
            # Cell 10: Tunnel Options Code
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {
                    "id": "tunnel_options",
                    "colab": {"base_uri": "https://localhost:8080/"}
                },
                "outputs": [],
                "source": [
                    "#@title Configure Tunneling Options\n",
                    "#@param {\"type\": \"string\", \"description\": \"Tunneling service to use\", \"options\": [\"ngrok\", \"gradio\"]} \n",
                    "tunnel_service = \"gradio\"  # \"ngrok\" or \"gradio\"\n",
                    "#@param {\"type\": \"string\", \"description\": \"ngrok auth token (if using ngrok)\"} \n",
                    "ngrok_token = \"\"  # Your ngrok token (optional)\n",
                    "#@param {\"type\": \"number\", \"description\": \"Port for the Gradio interface\"} \n",
                    "gradio_port = 7860\n",
                    "\n",
                    "# ============================================\n",
                    "# TUNNELING CONFIGURATION\n",
                    "# ============================================\n",
                    "\n",
                    "import subprocess\n",
                    "import os\n",
                    "import time\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# Check if ngrok is available if chosen\n",
                    "if tunnel_service == \"ngrok\":\n",
                    "    print(\"üîó Setting up ngrok tunneling...\")\n",
                    "    try:\n",
                    "        # Download and install ngrok\n",
                    "        subprocess.run([\"wget\", \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.tgz\"], check=True)\n",
                    "        subprocess.run([\"tar\", \"-xzf\", \"ngrok-v3-stable-linux-amd64.tgz\"], check=True)\n",
                    "        os.chmod(\"ngrok\", 0o755)\n",
                    "        \n",
                    "        if ngrok_token:\n",
                    "            subprocess.run([\"./ngrok\", \"config\", \"add-authtoken\", ngrok_token], check=True)\n",
                    "            print(\"‚úÖ ngrok configured with auth token\")\n",
                    "        else:\n",
                    "            print(\"‚ö†Ô∏è No ngrok token provided - using free tier\")\n",
                    "            \n",
                    "    except subprocess.CalledProcessError as e:\n",
                    "        print(f\"‚ùå Failed to setup ngrok: {e}\")\n",
                    "        print(\"üîÑ Falling back to Gradio tunneling...\")\n",
                    "        tunnel_service = \"gradio\"\n",
                    "        \n",
                    "elif tunnel_service == \"gradio\":\n",
                    "    print(\"üåê Using built-in Gradio tunneling...\")\n",
                    "else:\n",
                    "    print(\"‚ö†Ô∏è Unknown tunnel service, defaulting to Gradio\")\n",
                    "    tunnel_service = \"gradio\"\n",
                    "\n",
                    "print(f\"üõ£Ô∏è Tunnel service: {tunnel_service}\")\n",
                    "print(f\"üì° Port: {gradio_port}\")\n",
                    "\n",
                    "# Test port availability\n",
                    "try:\n",
                    "    result = subprocess.run([\"lsof\", \"-i\", f\":{gradio_port}\"], capture_output=True)\n",
                    "    if result.returncode == 0:\n",
                    "        print(f\"‚ö†Ô∏è Port {gradio_port} is already in use\")\n",
                    "        # Find available port\n",
                    "        for port in range(7860, 7900):\n",
                    "            result = subprocess.run([\"lsof\", \"-i\", f\":{port}\"], capture_output=True)\n",
                    "            if result.returncode != 0:\n",
                    "                gradio_port = port\n",
                    "                break\n",
                    "        print(f\"üîÑ Using alternative port: {gradio_port}\")\n",
                    "except FileNotFoundError:\n",
                    "    print(\"‚ö†Ô∏è lsof not available, skipping port check\")\n",
                    "\n",
                    "print(\"‚úÖ Tunneling configuration completed\")"
                ]
            },
            
            # Cell 11: Launch UI
            {
                "cell_type": "markdown",
                "metadata": {"id": "launch_ui"},
                "source": [
                    "#@title ## üöÄ Launch Advanced RVC Interface\n",
                    "\n",
                    "Start the Gradio interface with the configured tunneling options."
                ]
            },
            
            # Cell 12: Launch App Code
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {
                    "id": "launch_app",
                    "colab": {"base_uri": "https://localhost:8080/"}
                },
                "outputs": [],
                "source": [
                    "#@title Launch RVC Interface\n",
                    "#@param {\"type\": \"boolean\", \"description\": \"Enable debug mode\"} \n",
                    "debug_mode = False\n",
                    "#@param {\"type\": \"boolean\", \"description\": \"Auto-open browser (not recommended in Colab)\"} \n",
                    "auto_open = False\n",
                    "\n",
                    "# ============================================\n",
                    "# ADVANCED RVC INTERFACE LAUNCH\n",
                    "# ============================================\n",
                    "\n",
                    "import os\n",
                    "import sys\n",
                    "import subprocess\n",
                    "import threading\n",
                    "import time\n",
                    "from pathlib import Path\n",
                    "\n",
                    "# Add project directory to Python path\n",
                    "PROJECT_DIR = Path.cwd() / \"Advanced-RVC-Inference\"\n",
                    "if PROJECT_DIR.exists():\n",
                    "    sys.path.insert(0, str(PROJECT_DIR))\n",
                    "    os.chdir(PROJECT_DIR)\n",
                    "    print(f\"üìÇ Working in: {PROJECT_DIR}\")\n",
                    "\n",
                    "# Check for main app file\n",
                    "main_app_file = None\n",
                    "possible_files = [\"app.py\", \"main.py\", \"advanced_app.py\"]\n",
                    "for file in possible_files:\n",
                    "    if (PROJECT_DIR / file).exists():\n",
                    "        main_app_file = file\n",
                    "        break\n",
                    "\n",
                    "if not main_app_file:\n",
                    "    print(\"‚ùå No main application file found!\")\n",
                    "    print(\"Available files:\")\n",
                    "    for file in PROJECT_DIR.glob(\"*.py\"):\n",
                    "        print(f\"  - {file.name}\")\n",
                    "    exit(1)\n",
                    "\n",
                    "print(f\"üéØ Launching application: {main_app_file}\")\n",
                    "\n",
                    "# Environment variables\n",
                    "env = os.environ.copy()\n",
                    "env[\"PYTHONPATH\"] = str(PROJECT_DIR)\n",
                    "env[\"CUDA_VISIBLE_DEVICES\"] = \"0\"  # Use first GPU\n",
                    "\n",
                    "# Prepare launch command\n",
                    "cmd = [\"python\", main_app_file]\n",
                    "if debug_mode:\n",
                    "    cmd.append(\"--debug\")\n",
                    "\n",
                    "# Function to launch the app\n",
                    "def launch_colab_app():\n",
                    "    try:\n",
                    "        print(\"üöÄ Starting Advanced RVC Interface...\")\n",
                    "        print(f\"üîß Command: {' '.join(cmd)}\")\n",
                    "        \n",
                    "        if tunnel_service == \"ngrok\":\n",
                    "            # Start ngrok tunnel first\n",
                    "            ngrok_process = subprocess.Popen(\n",
                    "                [\"./ngrok\", \"http\", str(gradio_port)],\n",
                    "                stdout=subprocess.PIPE,\n",
                    "                stderr=subprocess.PIPE\n",
                    "            )\n",
                    "            time.sleep(2)  # Wait for ngrok to start\n",
                    "            \n",
                    "            # Start the app with ngrok\n",
                    "            app_process = subprocess.Popen(\n",
                    "                cmd + [\"--server.port\", str(gradio_port), \"--server.name\", \"0.0.0.0\"],\n",
                    "                env=env,\n",
                    "                stdout=subprocess.PIPE,\n",
                    "                stderr=subprocess.PIPE\n",
                    "            )\n",
                    "            \n",
                    "            # Get ngrok URL\n",
                    "            import urllib.request\n",
                    "            import json\n",
                    "            time.sleep(3)\n",
                    "            try:\n",
                    "                response = urllib.request.urlopen(\"http://localhost:4040/api/tunnels\")\n",
                    "                tunnels = json.loads(response.read().decode())\n",
                    "                public_url = tunnels[\"tunnels\"][0][\"public_url\"]\n",
                    "                print(f\"üåê Public URL: {public_url}\")\n",
                    "            except:\n",
                    "                print(\"üåê ngrok tunnel created (URL not available)\")\n",
                    "                \n",
                    "        else:\n",
                    "            # Use Gradio built-in tunneling\n",
                    "            cmd.extend([\n",
                    "                \"--server.port\", str(gradio_port),\n",
                    "                \"--server.name\", \"0.0.0.0\",\n",
                    "                \"--share\"  # This enables Gradio sharing\n",
                    "            ])\n",
                    "            \n",
                    "            app_process = subprocess.Popen(cmd, env=env)\n",
                    "        \n",
                    "        print(\"‚úÖ Application started successfully!\")\n",
                    "        print(f\"üîó Access URL will be displayed shortly...\")\n",
                    "        \n",
                    "        # Keep the process running\n",
                    "        app_process.wait()\n",
                    "        \n",
                    "    except Exception as e:\n",
                    "        print(f\"‚ùå Error launching application: {e}\")\n",
                    "        if debug_mode:\n",
                    "            import traceback\n",
                    "            traceback.print_exc()\n",
                    "\n",
                    "# Launch in a separate thread to prevent blocking\n",
                    "app_thread = threading.Thread(target=launch_colab_app, daemon=True)\n",
                    "app_thread.start()\n",
                    "\n",
                    "print(\"üîÑ Application is starting in the background...\")\n",
                    "print(\"‚è≥ Please wait a moment for the interface to become available.\")\n",
                    "\n",
                    "# Display status\n",
                    "time.sleep(5)\n",
                    "print(\"\\nüéâ Setup complete! The Advanced RVC Interface should be starting now.\")\n",
                    "print(\"üìñ Check the output above for the access URL.\")"
                ]
            }
        ],
        "metadata": {
            "colab": {
                "provenance": [],
                "collapsed_sections": ["install_dependencies"],
                "gpuType": "T4"
            },
            "kernelspec": {
                "display_name": "Python 3",
                "name": "python3"
            },
            "language_info": {
                "name": "python"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 0
    }
    
    # Write the enhanced notebook
    notebook_path = Path("notebooks/Advanced_RVC_Inference.ipynb")
    with open(notebook_path, 'w', encoding='utf-8') as f:
        json.dump(notebook, f, indent=1, ensure_ascii=False)
    
    print(f"‚úÖ Enhanced notebook created with {len(notebook['cells'])} cells")
    print("‚úÖ All cells have #@title and #@param annotations")
    print("‚úÖ CalledProcessError fixed - removed problematic -e flag")
    print("‚úÖ Branch reference fixed - using 'master' instead of 'main'")
    
    return notebook

if __name__ == "__main__":
    create_enhanced_notebook()